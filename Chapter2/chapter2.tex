%!TEX root = ../thesis.tex
%*******************************************************************************
%****************************** Second Chapter *********************************
%*******************************************************************************


\chapter{Deep learning for computational biology}

\ifpdf
    \graphicspath{{Chapter2/Figs/Raster/}{Chapter2/Figs/PDF/}{Chapter2/Figs/}}
\else
    \graphicspath{{Chapter2/Figs/Vector/}{Chapter2/Figs/}}
\fi

\section{Machine learning}
Machine learning methods are general-purpose approaches to learn functional relationships from data without the need to define them a priori~\citep{hastie_elements_2005,michalski_machine_2013,murphy_machine_2012}. In computational biology, their appeal is the ability to derive predictive models without a need for strong assumptions about underlying mechanisms, which are frequently unknown or insufficiently defined. As a case in point, the most accurate prediction of gene expression levels is currently made from a broad set of epigenetic features using sparse linear models~\citep{cheng_statistical_2011,karlic_histone_2010} or random forests~\citep{li_using_2015}; how the selected features determine the transcript levels remains an active research topic. Predictions in genomics~\citep{libbrecht_machine_2015,martens_predicting_2016}, proteomics~\citep{swan_application_2013}, metabolomics~\citep{kell_metabolomics_2005}, or sensitivity to compounds~\citep{eduati_prediction_2015} all rely on machine learning approaches as a key ingredient.

Most of these applications can be described within the canonical machine learning workflow, which involves four steps: data cleaning and pre-processing, feature extraction, model fitting, and evaluation (\autoref{fig:dl_ml}~(a)). It is customary to denote one data sample, including all covariates and features as input $x$ (usually a vector of numbers), and label it with its response variable or output value $y$ (usually a single number) when available.

\begin{figure}[htbp!]
\centering
\includegraphics[width=1.0\textwidth]{ml}
\caption[Machine learning and representation learning.]{Machine learning and representation learning. (a) The classical machine learning workflow can be broken down into four steps: data pre-processing, feature extraction, model learning, and model evaluation. (b) Supervised machine learning methods relate input features $x$ to an output label $y$, whereas unsupervised method learn factors about $x$ without observed labels. (c) Raw input data are often high dimensional and related to the corresponding label in a complicated way, which is challenging for many classical machine learning algorithms (left plot). Alternatively, higher-level features extracted using a deep model may be able to better discriminate between classes (right plot). (d) Deep networks use a hierarchical structure to learn increasingly abstract feature representations from the raw data.}
\label{fig:dl_ml}
\end{figure}

A supervised machine learning model aims to learn a function $f(x)=y$ from a list of training pairs $(x_1,y_1), (x_2,y_2),\ldots$ for which data are recorded (\autoref{fig:dl_ml}~(b)). One typical application in biology is to predict the viability of a cancer cell line when exposed to a chosen drug~\citep{eduati_prediction_2015,menden_machine_2013}. The input features $x$ would capture somatic sequence variants of the cell line, chemical makeup of the drug, and its concentration, which together with the measured viability (output label $y$) can be used to train a support vector machine, a random forest classifier or a related method (functional relationship $f$). Given a new cell line (unlabelled data sample $x^*$) in the future, the learnt function predicts its survival (output label $y^*$) by calculating $f(x^*)$, even if $f$ resembles more of a black box, and its inner workings of why particular mutation combinations influence cell growth are not easily interpreted. Both regression (where $y$ is a real number), and classification (where $y$ is a categorical class label) can be viewed in this way. As a counterpart, unsupervised machine learning approaches aim to discover patterns from the data samples $x$ itself, without the need for output labels $y$. Methods such as clustering, principal components analysis, and outlier detection are typical examples of unsupervised models applied to biological data.

The inputs $x$, calculated from the raw data, represent what the model `sees about the world', and their choice is highly problem specific (\autoref{fig:dl_ml}~(c)). Deriving most informative features is essential for performance, but the process can be labour-intensive and requires domain knowledge. This bottleneck is especially limiting for high dimensional data; even computational feature selection methods do not scale to assess the utility of vast number of possible input combinations. A major recent advance in machine learning is automating this critical step by learning a suitable representation of the data with deep artificial neural networks~\citep{bengio_representation_2013,lecun_deep_2015,schmidhuber_deep_2015} (\autoref{fig:dl_ml}~(d)). Briefly, a deep neural network takes the raw data at the lowest (input) layer, and transforms them into increasingly abstract feature representations by successively combining outputs from the preceding layer in a data-driven manner, encapsulating highly complicated functions in the process (Box 1). Deep learning is now one of the most active fields in machine learning and has been shown to improve performance in image- and speech recognition~\citep{deng_deep_2015,graves_generating_2013,hinton_deep_2012,krizhevsky_imagenet_2012,zeiler_visualizing_2014-1}, natural language understanding~\citep{bahdanau_neural_2014,lipton_critical_2015,sutskever_sequence_2014,xiong_dynamic_2016}, and most recently, in computational biology~\citep{alipanahi_predicting_2015,dahl_multi-task_2014,eickholt_dndisorder:_2013,kelley_basset:_2016,leung_deep_2014,sonderby_protein_2014,wang_chromatin_2015,zhou_predicting_2015}.

The potential of deep learning in high throughput biology is clear: in principle, it allows to better exploit the availability of increasingly large and high-dimensional datasets (e.g. from DNA sequencing, RNA measurements, flow cytometry, or automated microscopy) by training complex networks with multiple layers that capture their internal structure (\autoref{fig:dl_ml}~(c)). The learned networks discover high-level features, improve performance over traditional models, increase interpretability and provide additional understanding about the structure of the biological data.

In this review, we discuss recent and forthcoming applications of deep learning, with a focus on applications in regulatory genomics and biological image analysis. The goal of this review is not to provide comprehensive background on all technical details, which can be found in more specialized literature~\citep{bengio_practical_2012,bengio_representation_2013,deng_deep_2014,goodfellow_deep_2016,schmidhuber_deep_2015}. Instead, we aim to provide practical pointers and the necessary background to get started with deep architectures, review current software solutions, and give recommendations for applying them to data. The applications we cover are deliberately broad to illustrate differences and communalities between approaches; reviews focusing on specific domains can be found elsewhere~\citep{gawehn_deep_2016,leung_machine_2016,mamoshina_applications_2016,park_deep_2015}. Finally, we discuss both the potential and possible pitfalls of deep learning and contrast these methods to traditional machine learning and classical statistical analysis approaches.

\section{Artificial neural networks}
An artificial neural network, initially inspired by neural networks in the brain~\citep{farley_simulation_1954,mcculloch_logical_1943,rosenblatt_perceptron:_1958} consists of layers of interconnected compute units (neurons). In the canonical configuration, the network receives data in an input layer, which are then transformed in a nonlinear way through multiple hidden layers, before final outputs are computed in the output layer (\autoref{fig:dl_ann}~(a)). Neurons in a hidden or output layer are connected to all neurons of the previous layer. Each neuron computes a weighted sum of its inputs, and applies a nonlinear activation function to calculate its output (\autoref{fig:dl_ann}~(b)). The most popular activation function is the Rectified linear unit (ReLU, (\autoref{fig:dl_ann}~(b)), since it allows faster learning compared to alternatives (e.g. sigmoid or tanh unit)~\citep{glorot_deep_2011}. The depth of a neural network corresponds to the number of hidden layers, and the width to the maximum number of neurons in one of its layers. As it became possible to train networks with larger numbers of hidden layers, artificial neural networks were rebranded to ``deep networks''.

The weights between neurons are free parameters that capture the model's representation of the data, and are learned from input/output samples. Learning minimizes a loss function that measures the fit of the model output to the true label of a sample (\autoref{fig:dl_ann}~(a), bottom). This minimization is challenging, since the loss function is high dimensional and non-convex, similar to a landscape with many hills and valleys (\autoref{fig:dl_ann}~(c)). It took several decades before the backward propagation algorithm was first applied to compute a loss function gradient via chain rule for derivatives~\citep{rumelhart_learning_1988}, ultimately enabling efficient training of neural networks using stochastic gradient descent. During learning, the predicted label is compared with the true label to compute a loss for the current set of model weights. The loss is then backward propagated through the network to compute the gradients of the loss function and update (\autoref{fig:dl_ann}~(a)). While learning in deep neural networks remains an active area of research, existing software packages (Table 1) can already be applied without knowledge of the mathematical details involved.

Alternative architectures have been developed for specific applications, which differ in the way neurons are arranged. These include the convolutional neural network for images, the recurrent neural network for sequential data~\citep{lipton_critical_2015,sutskever_training_2013}, or the restricted Boltzmann machine~\citep{hinton_practical_2012,salakhutdinov_efficient_2010} and autoencoder~\citep{alain_regularized_2012,hinton_reducing_2006,kingma_auto-encoding_2013} for unsupervised learning. The multilayer perceptron, convolutional neural network, and recurrent neural network are most widely used in biology, and will be outlined in the following.


Alternative architectures have been developed for specific applications, which differ in the way neurons are arranged. These include the multilayer perceptron, convolutional neural networks, recurrent neural network, a for sequential data~\citep{lipton_critical_2015,sutskever_training_2013}, or restricted Boltzmann machines~\citep{hinton_practical_2012,salakhutdinov_efficient_2010} and autoencoders~\citep{alain_regularized_2012,hinton_reducing_2006,kingma_auto-encoding_2013} for unsupervised learning. The choice of network architecture and other parameters can be made in a data driven and objective way by assessing the model performance on a validation dataset.

\begin{figure}[htbp!]
\centering
\includegraphics[width=1.0\textwidth]{ann}
\caption[Building blocks and learning principles of a neural network.]{Building blocks and learning principles of a neural network. (a) Fully connected feedforward neural network with one input layer, hidden layer, and output layer.  Each layer $i$ consists of neurons which are connected to all neurons of the previous layer with weights $w(i)$. Given input $x$, neuron activations are calculated and forward propagated to the output layer to obtain a prediction $f(x)$. (b) Zoom-in view into one neuron, which computes the weighted sum of its inputs and applies a rectification function that thresholds negative signals to $0$, and passes through positive signal. (c) Gradient-based optimization of the loss function $L(w)$. In each step, the current weight vector (red dot) is moved along the direction of steepest descent $\Delta w$ (direction arrow) by learning rate $\eta$ (length of vector). Decaying the learning rate over time allows to explore different domains of the loss function by jumping over valleys at the beginning of the training (left side), and fine-tune parameters with smaller learning rates in later stages of the model training.}
\label{fig:dl_ann}
\end{figure}

\subsection{Multilayer perceptron}
The multilayer perceptron (MLP)~\citep{rosenblatt_perceptron:_1958} is the most basic artificial neural network, which consists of a sequence of fully-connected layers. Specifically, all neurons in a layer are connected to all neurons in the previous layer (\autoref{fig:dl_ann}~(a)). However, no connections exits between neurons within the same layer, as opposed to the recurrent neural network (\autoref{sec:dl_rnn}). A MLP with many layers and neurons can be very powerful, but is limited by a high number of parameters, which scales quadratically with the number of neurons per layer. Specialized architectures have been developed to reduce the number of parameters and avoid overfitting, which include the convolutional neural network.

\subsection{Convolutional neural network}
Convolutional neural networks (CNNs) were originally inspired by cognitive neuroscience and Hubel and Wiesel's seminal work on the cat's visual cortex, which was found to have simple neurons that respond to small motifs in the visual field, and complex neurons that respond to larger ones~\citep{hubel_shape_1963,hubel_period_1970}.

CNNs are designed to model input data in the form of multi-dimensional arrays, such as two-dimensional images with three colour channels~\citep{he_deep_2015,jarrett_what_2009,krizhevsky_imagenet_2012,lecun_backpropagation_1989,szegedy_rethinking_2015,zeiler_visualizing_2014-1}, or one-dimensional genomic sequences with one channel per nucleotide~\citep{alipanahi_predicting_2015,angermueller_accurate_2017,kelley_basset:_2016,zhou_predicting_2015}. The high dimensionality of these data (up to millions of pixels for high-resolution images) render training a fully connected neural network challenging, as the number of parameters of such a model would typically exceed the number of training data to fit them. To circumvent this, CNNs make additional assumptions on the structure of the network, thereby reducing the effective number of parameters to learn.

A convolutional layer consists of multiple maps of neurons, so called feature maps or filters, with their size being equal to the dimension of the input image (\autoref{fig:dl_image}). Two concepts allow reducing the number of model parameters: local connectivity and parameter sharing. First, unlike in a fully connected network, each neuron within a feature map is only connected to a local patch of neurons in the previous layer, the so-called receptive field. Second, all neurons within a given feature map share the same parameters. Hence, all neurons within a feature map scan for the same feature in the previous layer, however at different locations. Different feature maps might, for example, detect edges of different orientation in an image, or sequence motifs in a genomic sequence. The activity of a neuron is obtained by computing a discrete convolution of its receptive field, i.e. computing the weighted sum of input neurons, and applying an activation function.

In most applications, the exact position and frequency of features is irrelevant for the final prediction, such as recognizing objects in an image. Using this assumption, the pooling layer summarizes adjacent neurons by computing, for example, the maximum or average over their activity, resulting in a smoother representation of feature activities. By applying the same pooling operation to small image patches that are shifted by more than one pixel, the input image is effectively down-sampled, thereby further reducing the number of model parameters.

A CNN typically consists of multiple convolutional and pooling layers, which allows learning more and more abstract features at increasing scales from small edges, to object parts, and finally entire objects. One or more fully connected layers can follow the last pooling layer. Model hyper-parameters such as the number of convolutional layers, number of feature maps, or the size of receptive fields are application dependent and should be strictly selected on a validation data set (see below).


\begin{figure}[htbp!]
\centering
\includegraphics[width=1.0\textwidth]{cnn}
\caption[Convolutional neural network (CNN).]{Convolutional neural network (CNN). (a) A typical CNN consists of a number of convolutional and pooling layers, two fully connected layers, and one output layer. Each convolutional layer consists of multiple feature maps, with neurons responding to a particular feature in a receptive field (red square). One feature map responding to the membrane of a cell at a particular angle is highlighted on the edge. (b) Neuron activities result from a discrete convolution of their receptive field. (c) Max pooling computes the maximum neuron activity over a small patch, reducing the dimension of a convolutional layer.}
\label{fig:cnn}
\end{figure}


\subsection{Recurrent neural network} \label{sec:dl_rnn}
Recurrent neural networks (RNNs) are designed to model input sequences of variable length. They have been successfully applied to modelling long-range dependencies in natural text~\citep{sutskever_sequence_2014,bahdanau_neural_2014,xiong_dynamic_2016}, acoustic signals~\citep{deng_deep_2015,graves_speech_2013,hinton_deep_2012}, and biological sequences~\citep{agathocleous_protein_2010,sonderby_protein_2014,li_protein_2016,quang_danq:_2016}.  The input of a RNN is a sequence of vectors $x_1,\ldots,x_N$, such as the words of a sentence, nucleotides of a genomic sequence, or amino acids of a protein sequence. A RNN is called recurrent, because it applies the same operation at every time step:

\begin{align}
  h_t=\textrm{sigmoid}(W_{hx}x_t+W_{hh}h_{t-1}+b_h)
\end{align}

$h_t$ is the hidden state vector of the RNN, which is sequentially updated based on the current input $x_t$ and the previous hidden state $h_{t-1}$. $h_t$ is also denoted as the memory of the network, since it memorizes the input sequence $x_1,\ldots,x_t$ up to time step $t$. The last hidden state $h_T$ eventually memorises the entire input sequence. Importantly, the weights $W_{hx}$, $W_{hh}$, and $b_h$ are shared across time steps, which allows the network to process sequences of variable length. The output $y_t$ at time step $t$ is conditioned on the hidden state $h_t$, and thereby the entire past sequence:

\begin{align}
  y_t=f(W_{yh}+b_y)
\end{align}


$f$ is a task-specific activation function, such as the sigmoid function to model binary outputs or the softmax function to model categorical outputs. A RNN can either have a single output $y_T$ at the end of the sequence, for example to predict the class of a protein, or it can have an output at every time step $t$, for example to predict the secondary structure for an entire protein sequence. The network parameters $\theta=\left\{W_{hx},W_{hh},b_h,W_{yh},b_y\right\}$ are trained similarly to a feedforward neural network by comparing model outputs $y_t$ with true output labels $y^\prime_t$, and by backpropagating the error signal back over time. RNNs have long been considered as hard to train, since an incorrect parameter initialization can lead to vanishing or exploding gradients. While exploding gradients can be controlled by clipping, vanishing gradients can be circumvented by the use of advanced RNN architectures, such as the long short-term memory (LSTM)~\citep{hochreiter_long_1997} or gated recurrent unit (GRU)~\citep{chung_empirical_2014} network. The core idea behind the LSTM and GRU is the use of additional gates to update the memory of the network only at certain time steps.

The outputs $y_t$ of a RNN only depend on the past sequence, not the future sequence. In some applications, however, it is expedient to leverage information from the entire sequence. For example, the secondary structure of a protein sequence at position $t$ can depend on both amino acids to the left and to the right of $t$. A bidirectional RNN conditions its outputs $y_t$ on both the past and the future sequence. It consists of a forward and backward RNN, which scan the input sequence forwards and backwards, respectively, and concatenates their hidden state vectors:

\begin{align}
  \overrightarrow{h}_t&=\textrm{sigmoid}(\overrightarrow{W}_{hx}x_t+\overrightarrow{W}_{hh}h_{t-1}+\overrightarrow{b}_h) \\
  \overrightarrow{h}_t&=\textrm{sigmoid}(\overrightarrow{W}_{hx}x_t+\overrightarrow{W}_{hh}h_{t-1}+\overrightarrow{b}_h) \\
  h_t&=[\overrightarrow{h}_t, \overleftarrow{h}_t]
\end{align}

$\overrightarrow{h}_t$ and $\overleftarrow{h}_t$ is the hidden state vector at time step $t$ of the forward and backward RNN, which summarize the input sequence before and after time step $t$, respectively. The concatenated hidden state vector $h_t$ summarizes both the past and future input sequence, and thereby conditions $y_t$ on the entire sequence.

\begin{figure}[htbp!]
\centering
\includegraphics[width=1.0\textwidth]{rnn}
\caption[Recurrent neural network (RNN).]{Recurrent neural network (RNN). (a) A recurrent neural network (RNN) scans an input sequence x from left to right and updates at every time step $t$ its hidden state vector $h_t$ based on the previous hidden state $h_{t-1}$ and the current input $x_t$. Outputs $y_t$ are conditioned on $h_t$, which encodes the past sequence up to time step $t$. (b) A bidirectional RNN consists of a forward and backward RNN, which scan the input sequence in both directions. Outputs $y_t$ are conditioned on both the hidden state vector $\overrightarrow{h}_t$ of the forward RNN, and the hidden state vector $\overleftarrow{h}_t$ of the backward RNN, thereby on the entire sequence.}
\label{fig:rnn}
\end{figure}


\section{Deep learning for regulatory genomics}
Conventional approaches for regulatory genomics relate sequence variation to changes in molecular traits. One approach is to leverage variation between genetically diverse individuals to map quantitative trait loci (QTL). This principle has been applied to identify regulatory variants that affect gene expression levels~\citep{montgomery_transcriptome_2010,pickrell_understanding_2010}, DNA methylation~\citep{bell_dna_2011,gibbs_abundant_2010}, histone marks~\citep{grubert_genetic_2015,waszak_population_2015}, and proteome variation~\citep{albert_genetics_2014,battle_genomic_2015,parts_heritability_2014,vincent_stacked_2010} (\autoref{fig:dl_genomics}~(a)). Better statistical methods have helped to increase the power to detect regulatory QTLs~\citep{kang_accurate_2008,parts_joint_2011,rakitsch_modelling_2016,stegle_bayesian_2010}, however any mapping approach is intrinsically limited to variation that is present in the training population. Thus, studying effects of rare mutations in particular requires extremely large datasets.

An alternative is to train models that use variation between regions within a genome (\autoref{fig:dl_genomics}~(a)). Splitting the sequence into windows centred on the trait of interest gives rise to tens of thousands of training examples for most molecular traits even when using a single individual. Even with large datasets, predicting molecular traits from DNA sequence is challenging due to multiple layers of abstraction between effect of individual DNA variants and the trait of interest, as well as the dependence of the molecular traits on a broad sequence context and interactions with distal regulatory elements.

The value of deep neural networks in this context is twofold. First, classical machine learning methods cannot operate on the sequence directly, and thus require predefining features that can be extracted from sequence based on prior knowledge (e.g. the presence of absence of single-nucleotide variants (SNVs), k-mer frequencies, motif occurrences, conservation, known regulatory variants, or structural elements). Deep neural networks can help circumventing the manual extraction of features by learning them from data. Second, because of their representational richness, they can capture nonlinear dependencies in the sequence, interaction effects, and span wider sequence context at multiple genomic scales. Attesting to their utility, deep neural networks have been successfully applied to predict splicing activity~\citep{leung_deep_2014,xiong_human_2015}, specificities of DNA- and RNA binding proteins~\citep{alipanahi_predicting_2015}, or epigenetic marks and to study the effect of DNA sequence alterations~\citep{kelley_basset:_2016,zhou_predicting_2015}.

\begin{figure}[htbp!]
\centering
\includegraphics[width=1.0\textwidth]{genomics}
\caption[Principles of using neural networks for predicting molecular traits from DNA sequence.]{Principles of using neural networks for predicting molecular traits from DNA sequence. (a) DNA sequence and the molecular response variable along the genome for three individuals. Conventional approaches in regulatory genomics consider variations between individuals, whereas deep learning allows exploiting intra-individual variations by tiling the genome into sequence DNA windows centred on individual traits, resulting in large training datasets from a single sample. (b) One-dimensional convolutional neural network for predicting a molecular trait from the raw DNA sequence in a window. Filters of the first convolutional layer (example shown on the edge) scan for motifs in the input sequence. Subsequent pooling reduces the input dimension, and additional convolutional layers and can model interactions between motifs in the previous layer. (c) Response variable predicted by the neural network shown in (b) for a wild type and mutant sequence is used as input to an additional neural network that predicts a variant score and allows to discriminate normal from deleterious variants. (d) Visualization of a convolutional filter by aligning genetic sequences that maximally activate the filter and creating a sequence motif. (e) Mutation map of a sequence window. Rows correspond to the four possible base pair substitutions, columns to sequence positions. The predicted impact of any sequence change is colour coded. Letters on top denote the wild type sequence with the height of each nucleotide denoting the maximum effect across mutations (Figure panel adapted from \citet{alipanahi_predicting_2015}).}
\label{fig:dl_genomics}
\end{figure}

\subsection{Early applications of neural networks in regulatory genomics}
The first successful applications of neural networks in regulatory genomics replaced a classical machine learning approach with a deep model, without changing the input features. For example, \citet{xiong_human_2015} considered a fully connected feedforward neural network to predict the splicing activity of individual exons. The model was trained using more than $1,000$ pre-defined features extracted from the candidate exon and adjacent introns. Despite the relatively low number of 10,700 training samples in combination with the model complexity, this method achieved substantially higher prediction accuracy of splicing activity compared to simpler approaches, and in particular was able to identify rare mutations implicated in splicing misregulation.

\subsection{Convolutional designs}
More recent work using convolutional neural networks (CNNs) allowed direct training on the DNA sequence, without the need to define features~\citep{alipanahi_predicting_2015,angermueller_accurate_2017,kelley_basset:_2016,zhou_predicting_2015}. The CNN architecture allows to greatly reduce the number of model parameters compared to a fully connected network by applying convolutional operations to only small regions of the input space and by sharing parameters between regions. The key advantage resulting from this approach is the ability to directly train the model on larger sequence windows (Box 2, \autoref{fig:dl_genomics}~(b), \autoref{fig:cnn}).

\citet{alipanahi_predicting_2015} considered convolutional network architectures to predict specificities of DNA- and RNA binding proteins~\citep{alipanahi_predicting_2015}. Their DeepBind model outperformed existing methods, was able to recover known and novel sequence motifs, and could quantify the effect of sequence alterations and identify functional SNVs. A key innovation that enabled training the model directly on the raw DNA sequence was the application of a one-dimensional convolutional layer. Intuitively, the neurons in the convolutional layer scan for motif sequences and combinations thereof, similar to conventional position-weight matrices~\citep{stormo_use_1982}. The learning signal from deeper layers informs the convolutional layer which motifs are most relevant. The motifs recovered by the model can then be visualized as heatmaps or sequence logos (\autoref{fig:dl_genomics}~(d)).

\subsection{In silico prediction of mutation effects}
An important application of deep neural networks trained on the raw DNA sequence is to predict the effect of mutations in silico. Such model-based assessments of the effect of sequence changes complement methods based on QTL mapping, and can in particular help to uncover regulatory effects of rare SNVs or to fine-map likely causal genes. An intuitive approach for visualizing such predicted regulatory effects are mutation maps~\citep{alipanahi_predicting_2015}, whereby the effect of all possible mutations for a given input sequence is represented in a matrix view (\autoref{fig:dl_genomics}~(e)). The authors could further reliably identify deleterious SNVs, by training an additional neural network with predicted binding scores for a wild type and mutant sequence (\autoref{fig:dl_genomics}~(c)).

\subsection{Joint prediction of multiple traits and further extensions}
Following their initial successes, convolutional architectures have been extended and applied to a range of tasks in regulatory genomics. For example, \citet{zhou_predicting_2015} considered these architectures to predict chromatin marks from DNA sequence. The authors observed that the size of the input sequence window is a major determinant of model performance, where larger windows (now up to 1kb) coupled with multiple  convolutional layers enabled capturing sequence features at different genomic length scales. A second innovation was to use neural network architectures with multiple output variables (so called multi-task neural networks), here to predict multiple chromatin states in parallel. Multi-task architectures allow learning shared features between outputs, thereby improving generalization performance, and markedly reducing the computational cost of model training compared to learning independent models for each trait~\citep{dahl_multi-task_2014}.

In a similar vein, \citet{kelley_basset:_2016} developed the open-source deep learning framework Basset, to predict DNase-I hypersensitivity across multiple cell types and to quantify the effect of SNVs on chromatin accessibility. Again, the model improved prediction performance compared to conventional methods and was able to retrieve both known and novel sequence motifs that are associated with DNase-I hypersensitivity. A related architecture has also been considered by \citet{angermueller_accurate_2017} to predict DNA methylation states in single-cell bisulfite sequencing studies~\citep{angermueller_accurate_2017}. This approach combined convolutional architectures to detect informative DNA sequence motifs with additional features derived form neighbouring CpG sites, thereby accounting for methylation context. Most recently, \citet{koh_denoising_2017} applied CNNs to de-noise genome-wide chromatin immunoprecipitation followed by sequencing data in order to obtain a more accurate prevalence estimate for different chromatin marks~\citep{koh_denoising_2017}.

At present, CNNs are among the most widely used architectures to extract features from fixed sized DNA sequence windows. However, alternative architectures could also be considered. For example, recurrent neural networks (RNNs) are suited to model sequential data~\citep{lipton_critical_2015}, and have been applied for modelling natural language and speech~\citep{che_distilling_2015,deng_deep_2015,graves_speech_2013,hinton_deep_2012,sutskever_sequence_2014,xiong_dynamic_2016}, protein sequences~\citep{agathocleous_protein_2010,sonderby_protein_2014}, clinical medical data~\citep{che_distilling_2015}, and to a limited extent DNA sequences~\citep{lee_dna-level_2015}. RNNs are appealing for applications in regulatory genomics, because they allow modelling sequences of variable length, and to capture long-range interactions within the sequence and across multiple outputs. However, at present, RNNs are more difficult to train than CNNs, and additional work is needed to better understand the settings where one should be preferred over the other.

Complementary to supervised methods, unsupervised deep learning architectures learn low-dimensional feature representations from high-dimensional unlabelled data, similarly to classical principal components analysis or factor analysis, but using a non-linear model. Examples of such approaches are stacked autoencoders~\citep{vincent_stacked_2010}, restricted Boltzmann machines, and deep belief networks~\citep{hinton_reducing_2006}. The learnt features can be used to visualize data or as input for classical supervised learning tasks. For example, sparse autoencoders have been applied to classify cancer cases using gene-expression profiles~\citep{fakoor_using_2013}, or to predict protein backbones~\citep{lyons_predicting_2014-1}. Restricted Boltzmann machines can also be used for unsupervised pre-training of deep networks to subsequently train supervised models of protein secondary structures~\citep{spencer_deep_2015}, disordered protein regions~\citep{eickholt_predicting_2012,eickholt_dndisorder:_2013}, or amino-acid contacts~\citep{eickholt_predicting_2012}. Skip-gram neural networks have been applied to learn low-dimensional representations of protein sequences and improve protein classification~\citep{asgari_protvec:_2015}. In general, unsupervised models are a powerful approach if large quantities of unlabelled data are available to pre-train complex models. Once trained, these models can help to improve performance on classification tasks, for which smaller numbers of labelled examples are typically available.




\section{Deep learning for biological image analysis}

Historically, perhaps the most important successes of deep neural networks have been in image analysis. Deep architectures trained on millions of photographs can famously detect objects in pictures better than humans do~\citep{he_deep_2015}. All current state-of-the-art models in image classification, object detection, image retrieval, and semantic segmentation, make use of neural networks. The convolutional neural network (Box 2) is the most common network architecture for image analysis. Briefly, a CNN performs pattern matching (convolution) and aggregation (pooling) operations (Box 2). At a pixel level, the convolution operation scans the image with a given pattern, and calculates the strength of the match for every position. Pooling determines the presence of the pattern in a region, for example by calculating the maximum pattern match in smaller patches (max-pooling), thereby aggregating region information into a single number (\autoref{fig:cnn}). The successive application of convolution and pooling operations is at the core of most network architectures used in image analysis.

\subsection{First applications in computational biology - pixel level classification}

The early applications of deep networks for biological images focused on pixel level tasks, with additional models building on the network outputs. For example, \citet{ning_toward_2005} applied convolutional neural networks in a study that predicted abnormal development in C. elegans embryo images. They trained a CNN on 40x40 pixel patches to classify the centre pixel to cell wall, cytoplasm, nucleus membrane, nucleus, or outside medium, using three convolutional and pooling layers, followed by a fully connected output layer. The model predictions were then fed into an energy-based model for further analysis. CNNs have outperformed standard methods, e.g. Markov random fields and conditional random fields~\citep{li_markov_2009} in such raw data analysis tasks, for example restoring noisy neural circuitry images~\citep{jain_supervised_2007}.

Adding layers allows moving from clearing up pixel noise to modelling more abstract image features.~\citep{ciresan_mitosis_2013} used five convolutional and pooling layers, followed by two fully connected layers, to find mitosis in breast histology images. This model won the mitosis detection challenge at the International Conference of Pattern Recognition 2012, outperforming competitors by a substantial margin. The same approach was also used to segment neuronal structures in electron microscopy images, classifying each pixel as membrane or non-membrane~\citep{ciresan_deep_2012}. In these applications, while the CNNs were trained in an end-to-end manner, additional post-processing was required to obtain class probabilities from the outputs for new images.

Successive pooling operations lose information on localization, as only summaries are retained from larger and larger regions. To avoid this, skip links can be added to carry information from early, fine-grained layers forward to deeper ones. The currently best performing pixel level classification method for neuronal structures (U-Net,~\citep{ronneberger_u-net:_2015}) employs an architecture in which neurons take inputs from lower layers to localize high resolution features, as well as to overcome the arbitrary choice of context size.


\subsection{Analysis of whole cells, cell populations, and tissues}

In many cases, pixel-level predictions are not required. For example, \citet{xu_deep_2014} classified colon histopathology images into cancerous and non-cancerous, finding that supervised feature learning with deep networks was superior to using hand-crafted features~\citep{xu_deep_2014}. \citet{parnamaa_accurate_2016} used CNNs to classify pre-segmented image patches of individual yeast cells carrying a fluorescent protein to different subcellular localization patterns~\citep{parnamaa_accurate_2016}. Again, deep networks outperformed methods based on traditional features. Further, \citet{kraus_classifying_2015} combined the segmentation and classification tasks into a single architecture that can be learned end-to-end, and applied the model to full resolution yeast microscopy images~\citep{kraus_classifying_2015}. This approach allowed classifying entire images without performing segmentation as a pre-processing step. CNNs have even been applied to count bacterial colonies in agar plates~\citep{ferrari_bacterial_2015}. Since the early de-noising applications on the pixel level, the field has been moving towards end-to-end image analysis pipelines that make use of large bioimage datasets, and the representational power of CNNs.

\begin{figure}[htbp!]
\centering
\includegraphics[width=1.0\textwidth]{image}
\caption[Deep neural network for image analysis.]{Convolution and pooling operators are stacked, thereby creating a deep network for image analysis. In standard applications, convolution layers are followed by a pooling layer (Box 2). In this example, the lowest level convolutional units operate on 3x3 patches, but deeper ones use and capture information from larger regions. These convolutional pattern-matching layers are followed by one or multiple fully connected layers to learn which features are most informative for classification. For each layer with learnable weights, three example images that maximize some neuron output are shown.}
\label{fig:dl_image}
\end{figure}


\subsection{Re-using trained models}

Training convolutional neural networks requires large datasets. While biological data acquisition can be expensive, this does not mean that deep neural networks cannot be used when millions of images are not available. Regardless of image source, lower levels of the network tend to capture similar signal (edges, blobs) that are not specific to the training data and the application, but instead recur in perceptual tasks in general. Thus, convolutional neural networks can re-use pictures from a similar domain to help with learning, or even be pre-trained on other data, thereby requiring fewer images to fine-tune the model for the task of interest. Indeed, \citet{donahue_decaf:_2013} showed that features learned from millions of images to classify objects, can successfully be used in image retrieval, detection or classification on new domains where only hundreds of images are labelled. The effectiveness of such an approach depends on the similarity between the training data and the new domain~\citep{ghahramani_how_2014}.

The concept of transferring model parameters has also been successful in bioimage analysis. For example, \citet{zhang_deep_2015} showed that features learned from natural images can be transferred to biological data, improving the prediction of Drosophila melanogaster developmental stages from in situ hybridization images. The model was first pre-trained on data from the ImageNet~\citep{russakovsky_imagenet_2015}, an open corpus of more than one million diverse images, to extract rich features at different scales. \citet{xie_beyond_2015} further used synthetic images to train a CNN for automatic cell counting in microscopy images. We expect that network repositories that host pre-trained models will emerge for biological image analysis; such efforts already exist for general image processing tasks (see learning section below). These trained models could be downloaded and used as feature extractors (\autoref{fig:dl_image_pretrain}), or further fine-tuned and adapted to a particular task on small-scale data.

\begin{figure}[htbp!]
\centering
\includegraphics[width=1.0\textwidth]{image_pretrain}
\caption[Feature extraction with pre-trained convolutional neural networks.]{A pre-trained network can be used as a generic feature extractor. Feeding input into the first layer (left) gives a low-level feature representation in terms of patterns (left to right) present in smaller patches in every cell (top to bottom). Neuron activations extracted from deeper layers (right) give rise to more abstract features that capture information from a larger segment of the image.}
\label{fig:dl_image_pretrain}
\end{figure}

\subsection{Interpreting and visualizing convolutional networks}
Convolutional neural networks have been successful across many domains. In interpreting their performance, it is useful to understand the features they capture.

\textit{Visualizing input weights.} One way to understand what a particular neuron represents is to look for inputs that maximally activate it. Under some mathematical constraints, these patterns are proportional to the incoming weights. \citet{krizhevsky_imagenet_2012} visualized weights in the first convolutional layer, and found that these maximally activating patterns correspond to colour blobs, edges at different orientations, and Gabor-like filters (\autoref{fig:dl_image_pretrain}). Gabor filters are widely used pre-defined features in image analysis; neural networks rediscover them in a data driven way as a useful component of the image model. Higher layer weights can be visualized as well, but as the inputs are not pixels, their weights are more difficult to interpret.

\textit{Finding images that maximize neuron activity.} To understand the deeper layers in terms of input pixels, \citet{girshick_rich_2014} and \citet{simonyan_deep_2013} generated images that maximize the output of individual neurons. While this approach yields no explicit representation, it can provide an overview of the type of features that differentiate images with large neuron activity from all others.  Such visualizations tend to show that second layer features combine edges from the first layer, thereby detecting corners and angles, deeper layer neurons activate for specific object parts (e.g. noses, eyes), and the deepest layers detect whole objects (e.g. faces, cars). It is complicated to hand-engineer features that look specifically for noses, eyes, or faces, but neural networks can learn these features solely from input-output examples.

\textit{Hiding important image parts.} To understand which image parts are important for determining the value of each feature, \citet{zeiler_visualizing_2014-1} occluded images with smaller grey boxes. The parts that are most influential will drastically change the feature value when occluded. In a similar vein, \citet{simonyan_deep_2013} and \citet{springenberg_striving_2014} visualised which individual pixels make the most difference in the feature, and \citet{bach_pixel-wise_2015} developed pixel relevance for individual classification decisions in a more general framework. This information can also be used for object localisation or segmentation, as the sensitive image pixels usually correctly correspond to the true object. \citet{kraus_classifying_2015} used this idea to effectively localize cells in large microscopy images.

\textit{Visualising similar inputs in two dimensions.} Visualising the CNN representations can help gauge what inputs get mapped to similar feature vectors, and hence understand what the model has learned. \citet{donahue_decaf:_2013} projected CNN features into two dimensions to show that each subsequent layer transforms data to be more and more separable by a linear classifier. In general, different CNN visualisation methods show that higher layer features are more specific to the learning task, while low-level features tend to capture general aspects of images, such as edges, corners, etc.


\section{Off-the-shelf tools and practical considerations}

\subsection{Deep learning frameworks}

Deep learning frameworks have been developed to easily build neural networks from existing modules on a high level. The most popular ones are Caffe~\citep{jia_caffe:_2014}, Theano~\citep{bastien_theano:_2012}, Torch7~\citep{collobert_torch7:_2011}, and TensorFlow~\citep{abadi_tensorflow:_2016} (Table 1), which differ in modularity, ease of use and the way models are defined and trained.

Caffe~\citep{jia_caffe:_2014} is developed by the Berkeley Vision and Learning Center and is written in C++. The network architecture is specified in a configuration file and models can be trained and used via command line, without writing code at all. Additionally, Python and MATLAB interfaces are available. Caffe offers one of the most efficient implementations for CNNs and provides multiple pre-trained models for image recognition, make it well suited for computer vision tasks. As a downside, custom models need to be implemented in C++, which can be difficult. Additionally, Caffe is not optimized for recurrent architectures.

Theano~\citep{bastien_theano:_2012} is developed and maintained by the University of Montreal and written in Python and C++. Model definitions follow a declarative instead of an imperative programing paradigm, which means that the user specifics what needs to be done, not in which order. A neural network is declared as a computational graph, which is then compiled to native code and executed. This design allows Theano to optimize computational steps and to automatically derive gradientsâ€”one of its main strengths. Consequently, Theano is well suited for building custom models and offers particularly efficient implementations for RNNs. Software wrappers such as Keras (\url{https://github.com/fchollet/keras}) or Lasagne (\url{https://github.com/Lasagne/Lasagne}) provide additional abstraction and allow building networks from existing components, and reuising pre-trained networks. The major drawback of Theano are frequently long compile times when building larger models.

Torch7~\citep{collobert_torch7:_2011} was initially developed at the University of New York and is based on the scripting language LuaJIT. Networks can be easily built by stacking existing modules and are not compiled, hence making it more suited for fast prototyping than Theano. Torch7 offers an efficient CNN implementation and access to a range of pre-trained models. A possible downside is the need of the user to be familiar with the LuaJIT scripting language. Also, LuaJIT is less suited for building custom recurrent networks.

TensorFlow~\citep{abadi_tensorflow:_2016} is the most recent deep learning framework developed by Google. The software is written in C++ and offers interfaces to Python. Similar to Theano, a neural network is declared as a computational graph, which is optimized during compilation. However, the shorter compile time makes it more suited for prototyping. A key strength of TensorFlow is native support for parallelization across different devices, including CPUs and GPUs, and compute nodes on a cluster. The accompanying tool TensorBoard allows to conveniently visualize networks in a web browser and to monitor training progress, e.g. learning curves or parameter updates. At present, TensorFlow provides the most efficient implementation for RNNs. The software is recent, and under active development, hence only few pre-trained models are currently available.

\begin{table}
\centering
\begin{tabular}{p{2.5cm}|p{2.6cm}|p{2.6cm}|p{2.6cm}|p{2.6cm}}
\toprule
& \textbf{Caffee} & \textbf{Theano} & \textbf{Torch7} & \textbf{Tensorflow} \\
\hline
\textit{Core language} & C++ & Python, C++ & LuaJIT  & C++\\
\hline
\textit{Interfaces} & Python, Matlab & Python & C & Python, R \\
\hline
\textit{Wrappers} & & Lasagne, Keras, sklearn-theano & & Keras, Pretty Tensor, Scikit Flow \\
\hline
\textit{Programming paradigm} & Imperative & Declarative & Imperative & Declarative \\
\hline
\textit{Well suited for} & CNNs, Reusing existing models, Computer vision & Custom models, RNNs & Custom models, CNNs, Reusing existing models & Custom models, Parallelization, RNNs \\
\bottomrule
\end{tabular}
\caption{Overview of existing deep learning frameworks, comparing four widely used software solutions.}
\label{tab:dl_tools}
\end{table}


\subsection{Data preparation}

Training data are the key for every machine learning applications. Since more data with informative features usually result in better performance, effort should be spent on collecting, labelling, cleaning, and normalizing data.

\subsubsection{Required dataset sizes}
Most of the successful applications of deep learning have been in supervised learning settings, where sufficient labelled training samples are available to fit complex models. As a rule of thumb, the number of training samples should be at least as high as the number of model parameters, although special architectures and model regularization (see below) can help to avoid overfitting if training data are scarce~\citep{bengio_practical_2012}.

Central problems in regulatory genomics, e.g. predicting molecular traits from genotype, are limited in the number of training instances; hundreds to at most tens of thousands of training examples are typical. The strategy of considering a sequence windows centred on the trait of interest (e.g. splice site, transcription factor binding site, or epigenetic marks, \autoref{fig:dl_genomics}~(a)) is now a widely used approach and helps increasing the number of input-output pairs from a single individual.

In image analysis, data can be abundant, but manually curated and labelled training examples are typically difficult to obtain. In such instances, the training set can be augmented by scaling, rotating, or cropping the existing images, an approach that also enhances robustness~\citep{krizhevsky_imagenet_2012}. Another strategy is to reuse a network that was pre-trained on a large dataset for image recognition (e.g. AlexNet~\citep{krizhevsky_imagenet_2012}, VGG~\citep{simonyan_very_2014}, GoogleNet~\citep{szegedy_rethinking_2015}, or ResNet~\citep{he_deep_2015}), and to fine-tune its parameters on the data set of interest (e.g. microscopy images for a particular segmentation task). Such an approach exploits that different data sets share important characteristics and features, such as edges or curves, which can be transferred between them. Caffe, Lasagne, Torch, and to a limited extend TensorFlow provide repositories with pre-trained models.

\subsubsection{Partitioning data into training, validation, and test set}
Machine learning models need to be trained, selected, and tested on independent data sets to avoid over-fitting and assure that the model will generalize to unseen data. Hold-out validation, partitioning the data into a training, validation, and test set, is the standard for deep neural networks (\autoref{fig:dl_tricks}~(c)). The training set is used to learn models with different hyper-parameters, which are then assessed on the validation set. The model with best performance, e.g. prediction accuracy or mean squared error, is selected, and further evaluated on the test set to quantify the performance on unseen data and for comparison to other methods. Typical dataset proportions are 60\% for training, 10\% for validation, and 30\% for model testing. If the dataset is small, k-fold cross validation or bootstrapping can be used instead~\citep{hastie_elements_2005}.

\subsubsection{Normalization of raw data}
Appropriate choices for data normalization can help to accelerate training and the identification of a good local minimum.

Categorical features such as DNA nucleotides first need to be encoded numerically. They are typically represented as binary vectors with all but one entry set to zero, which indicates the category (one-hot coding). For example, DNA nucleotides (categories) are commonly encoded as A = (1 0 0 0), G = (0 1 0 0), C = (0 0 1 0), and T = (0 0 0 1) (\autoref{fig:dl_tricks}~(a)). A DNA sequence can then be represented as a binary string by concatenating the encoding nucleotides, and treating each nucleotide as an independent input feature of a feed forward neural network. In a CNN, the four bits of each encoded base are commonly considered analogously to colour channels of an image to preserve the entity of a nucleotide.

Numerical features are typically zero-centred by subtracting their mean value. Image pixels are usually not zero-centred individually, but jointly by subtracting the mean pixel intensity per colour channel~\citep{karpathy_cs231n_2016}. An additional common normalization step is to standardize features to unit variance. Whiting can be used to decorrelate features (\autoref{fig:dl_tricks}~(b)), but can be computationally involved, since it requires computing the feature covariance matrix~\citep{hastie_elements_2005}. If the distribution of features is skewed due to few extreme values, log transformations or similar processing steps may be appropriate. Validation and test data need to be normalized consistently with the training data. For example, features of the validation data need to be zero-centred by subtracting the mean computed on the training data, not on the validation data.

\begin{figure}[htbp!]
\centering
\includegraphics[width=1.0\textwidth]{tricks}
\caption[Data normalization and pre-processing for deep neural networks.]{Data normalization and pre-processing for deep neural networks. (a) DNA sequence one-hot encoded as binary vectors using codes A = 1 0 0 0, G = 0 1 0 0, C = 0 0 1 0, and T = 0 0 0 1. (b) Continuous data (green) after zero-centring (orange), scaling to unit variance (blue), and whiting (purple). (c) Hold-out validation partitions the full data set randomly into training (${\approx}60\%$), validation (${\approx}10\%$) and test set (${\approx}30\%$). Models are trained with different hyper-parameters on the training set, from which the model with the highest performance on the validation set is selected. The generalization performance of the model is assessed and compared with other machine learning methods on the test set. (d) The shape of the learning curve indicates if the learning rate is too low (red, shallow decay), too high (orange, steep decay followed by saturation), or appropriate for a particular learning task (green, gradual decay). (e) Large differences in the model performance on the training set (blue) and validation set (green) indicates overfitting. Stopping the training as soon as the validation set performance starts to drop (early stopping) can prevent overfitting. (f) Illustration of the dropout regularization. Shown is a feed forward neural network after randomly dropping out neurons (crossed out), which reduces the sensitivity of neurons to neurons in the previous layer due to non-existent inputs (greyed edges).}
\label{fig:dl_tricks}
\end{figure}

\subsection{Model building}

\subsubsection{Choice of model architecture}
After preparing the data, design choices about the model architectures need to be made. The default architecture is a feedforward neural network with fully connected hidden layers, which is an appropriate starting point for many problems. Convolutional architectures are well suited for multi- and high-dimensional data, such as two-dimensional images or abundant genomic data. Recurrent neural networks can capture long-range dependencies in sequential data of varying lengths, such as text, protein, or DNA sequences. More sophisticated models can be built by combining different architectures. To describe the content of an image, for example, a CNN can be combined with an RNN, where the CNN encodes the image and the RNN generates the corresponding image description~\citep{vinyals_show_2015,xu_ask_2015}. Most deep learning frameworks provide modules for different architectures and their combinations.

\subsubsection{Determining the number of neurons in a network}
The optimal number of hidden layers and hidden units is problem dependent and should be optimized on a validation set. One common heuristic is to maximize the number of layers and units without overfitting the data. More layers and units increase the number of representable functions and local optima, and empirical evidence show that it makes finding a good local optimum less sensitive to weight initialization~\citep{dauphin_identifying_2014}.

\subsubsection{Model training}
The goal of model training is to find parameters $w$ that minimize an objective function $L(w)$, which measures the fit between the predictions the model parameterized by $w$ and the actual observations. The most common objective functions are the cross-entropy for classification and mean-squared error for regression. Minimizing $L(w)$ is challenging since it is high-dimensional and non-convex (\autoref{fig:dl_tricks}, \autoref{fig:dl_ann}).

\subsubsection{Stochastic Gradient Descent}
Stochastic gradient descent is widely used to train deep models. Starting from an initial set of parameters $w_0$, the gradient $\Delta w$ of $L$ with respect to $w$ is computed for a random batch of only few, e.g. 128, training samples. $\Delta w$ points to the direction of steepest descent, towards which w is updated with step size eta, the learning rate (\autoref{fig:dl_ann}~(c)). At each step, the parameters are updated into the direction of steepest descent until a minimum is reached, analogously to a ball running down a hill to a valley~\citep{bengio_practical_2012}. The training performance strongly depends on parameter initialization, learning rate, and batch size.

\subsubsection{Parameter initialization}
In general, model parameters should be initialized randomly to avoid local optima determined by a fixed initialization. Starting points for model parameters can be sampled independently from a normal distribution with small variance, or more commonly from a normal distribution with its variance scaled inversely by the number of hidden units in the input layer~\citep{glorot_understanding_2010,he_delving_2015}.

\subsubsection{Learning rate and batch size}
The learning rate and batch size of stochastic gradient descent need to be chosen with care, since they can strongly impact training speed and model performance. Different learning rates are usually explored on a logarithmic scale such as 0.1, 0.01, or 0.001, with 0.01 as recommended default value~\citep{bengio_practical_2012}. A batch size of 128 training samples is suitable for most applications. The batch size can be increased to speed up training, or decreased to reduce memory usage, which can be important for training complex models on memory-limited GPUs. The optimum learning rate and batch size are connected, with larger batch sizes typically requiring smaller learning rates.

\subsubsection{Learning rate decay}
The learning rate can be gradually reduced during training, which is based on the idea that larger steps may be helpful in early training stages in order to overcome possible local optima, whereas smaller step sizes allowing exploring narrow parameter regions of the loss function in advanced stages of training. Common approaches include to linearly reduce the learning rate by a constant factor such as 0.5 after the validation loss stops improving, or exponentially after every training iteration or epoch~\citep{bengio_practical_2012,gawehn_deep_2016}.

\subsubsection{Momentum}
Vanilla stochastic gradient descent can be extended by `momentum', which usually improves training~\citep{sutskever_training_2013}. Instead of updating the current parameter vector $w_t$ at time $t$ by the gradient vector $\Delta w_{t+1}$ directly, a fraction of the previous update is added to the current one. With momentum rate $\nu$, weights are updated by a momentum vector  This approach can help to take larger steps in directions where gradients point consistently, and therefore speed up the convergence. The momentum rate $\nu$ can be set between $[0;1]$, and a typical value is $0.9$. Nesterov momentum~\citep{nesterov_method_1983,nesterov_introductory_2013} is a special form of the same concept, which sometimes provides additional advantages.

\subsubsection{Per-parameter adaptive learning rate methods}
To reduce the sensitivity to the specific choice of the learning rate, adaptive learning rate methods, such as RMSprop, Adagrad~\citep{duchi_adaptive_2011}, and Adam~\citep{kingma_adam:_2014}, have been developed that one appropriately adapt the learning rate per parameter during. The most recent method, Adam, combines the strengths of previous methods RMSprop and Adagrad, and is generally recommended for many applications.

\subsubsection{Batch normalization}
Batch normalization~\citep{ioffe_batch_2015} is a recently described approach to reduce the dependency of training to the parameter initialization, speed up training, and reduce overfitting. It is easy to implement, has marginal additional compute costs, and has hence become common practice. Batch normalization zero centres and normalizes data not only at the input layer, but also at hidden layers before the activation function. This approach allows using higher learning rates and hence also accelerates training.

\subsubsection{Analyzing the learning curve}
To validate the learning process, the loss should be monitored as a function of the number of training epochs, i.e. the number times the full training set has been traversed (\autoref{fig:dl_tricks}~(d)). If the learning curve decreases slowly, the learning rate may be too small and should be increased. If the loss decreases steeply at the beginning but saturates quickly, the learning rate may to too high. Extreme learning rates can result in an increasing or fluctuating learning curve~\citep{bengio_practical_2012,karpathy_cs231n_2016}.

\subsubsection{Monitoring training and validation performance}
In parallel to the training loss, it is recommended to monitor the target performance such as the accuracy for both the training and validation set during training (\autoref{fig:dl_tricks}~(e)). A low or decreasing validation performance relative to the training performance indicates overfitting~\citep{bengio_practical_2012,karpathy_cs231n_2016}.

\subsubsection{Avoiding overfitting}
Deep neural networks are notoriously difficult to train, and overfitting to data is a major challenge, since they are non-linear and have many parameters. Overfitting results from a too complex model relative to the size of the training set, and can thus be reduced by decreasing the model complexity, e.g. the number of hidden layers and units, or by increasing the size of the training set, e.g. via data augmentation (see above). The following training guidelines can help to avoid overfitting.

Dropout~\citep{srivastava_dropout:_2014} is the most common regularization technique and often one of the key ingredients to train deep models. Here, the activation of some neurons is randomly set to zero (`dropped out') during training in each forward pass, which intuitively results in an ensemble of different networks whose predictions are averaged (\autoref{fig:dl_tricks}~(e)). The dropout rate corresponds to the probability that a neuron is dropped out, where 0.5 is a sensible default value. In addition to dropping out hidden units, input units can be dropped, however usually at a lower rate. Dropout is often combined with regularizing the magnitude or parameter values by the L2 norm, and less commonly the L1 norm.

Another popular regularization method is `early stopping'. Here, training is stopped as soon as the validation performance starts to saturate or deteriorate, and the parameters with the best performance on the validation set chosen.

Layer-wise pre-training~\citep{bengio_greedy_2007,salakhutdinov_efficient_2012} should be considered if the model overfits despite the mentioned regularization techniques. Instead of training the entire network at once, layers are first pre-trained unsupervised using autoencoders or restricted Boltzmann machines. Afterwards, the entire network is fine-tuned using the actual supervised learning objective.

\subsubsection{Hyper-parameter optimization}
\autoref{tab:dl_params} summarizes recommendations and starting points for the most common hyper-parameters, excluding architecture dependent hyper-parameters such as the size and number of filters of a CNN. Since the best hyper-parameter configuration is data and application dependent, models with different configurations should be trained and their performance be evaluated on a validation set. As the number of configurations grows exponentially with the number of hyperparameters, trying all of them is impossible in practice~\citep{bengio_practical_2012}. It is therefore recommended to optimize the most important hyper-parameters such as the learning rate, batch size, or length of convolutional filters independently via line search, i.e. trying different values while keeping all other hyper-parameters constant. The refined hyper-parameter space can then be further explored by random sampling, and settings with the best performance on the validation set are chosen. Frameworks such as Spearmint~\citep{snoek_practical_2012}, Hyperopt~\citep{bergstra_hyperparameter_2013}, or SMAC~\citep{hutter_sequential_2011} allow to automatically explore the hyper-parameter space using Bayesian optimization. However, although conceptually more powerful, they are at present more difficult to apply and parallelize than random sampling.

\subsubsection{Training on GPUs}
Training neural networks is more time consuming compared to shallow models, and can take hours, days, or even weeks, depending on the size of training set and model architecture. Training on GPUs can considerably reduce the training time (commonly by ten fold or more) and is therefore crucial for evaluating multiple models efficiently. The reason for this speedup is that learning deep networks requires large numbers of matrix multiplications, which can be parallelized efficiently on GPUs. All state of the art deep learning frameworks provide support to train models on either CPUs or GPUs without requiring any knowledge about GPU programming. On desktop machines, the local GPU card can often be used if the framework supports the specific brand. Alternatively, commercial providers provide GPU cloud compute clusters.

\subsubsection{Pitfalls}
No single method is universally applicable, and the choice of whether and how to use deep learning approaches will be problem specific. Conventional analysis approaches will remain valid and have advantages when data are scarce or if the aim is to assess statistical significance, which is currently difficult using deep learning methods. Another limitation of deep learning is the increased training complexity, which applies both to model design and the required compute environment.

\begin{table}
\centering
\begin{tabular}{p{4cm}|p{5cm}|p{4cm}}
\textbf{Name} & \textbf{Range} & \textbf{Default value} \\
\toprule
Learning rate & 0.1, 0.01, 0.001, 0.0001 & 0.01 \\
Batch size & 64, 128, 256 & 128 \\
Momentum rate & 0.8, 0.9, 0.95 & 0.9 \\
Weight initialization & Normal, Uniform, Glorot uniform & Glorot uniform \\
Per-parameter adaptive learning rate methods & RMSprop, Adagrad, Adadelta, Adam & Adam \\
Batch normalization & yes, no & yes \\
Learning rate decay & None, linear, exponential & Linear (rate 0.5) \\
Activation function & Sigmoid, Tanh, ReLU, Softmax & ReLU \\
Dropout rate & 0.1, 0.25, 0.5, 0.75 & 0.5 \\
l1, l2 regularization & 0, 0.01, 0.001 & \\
\bottomrule
\end{tabular}
\caption{Central parameters of a neural network and recommended settings.}
\label{tab:dl_params}
\end{table}



\section{Conclusion}
Deep learning methods are a powerful complement to classical machine learning tools and other analysis strategies. Already, these approaches have found use in a number of applications in computational biology, including regulatory genomics and image analysis. The first publicly available software frameworks have helped to reduce the overhead of model development, and provided a rich, accessible toolbox to practitioners. We expect that continued improvement of software infrastructure will make deep learning applicable to a growing range of biological problems.
